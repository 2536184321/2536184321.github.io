<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录刷题总结</title>
    <link href="/2023/10/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="代码随想录刷题总结"><a href="#代码随想录刷题总结" class="headerlink" title="代码随想录刷题总结"></a>代码随想录刷题总结</h1><p>最近把随想录剩下的题目都过了一遍。但是很多题目，我看了题解才会做，可能过几天就忘了。所以要多多重复，但要是每次复习都从头到尾一字不漏的看一遍，太浪费时间。</p><p>于是，我认为应该主动去总结，复习的时候写下自己的理解和方法论，方便之后的巩固，节省很多时间，减轻记忆负担。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a>，使用滑动窗口，滑动窗口的题目主要关注左边元素弹出，右边元素加入，窗口内状态的变化。这个题要求窗口最小长度，所以在满足和大于target的基础上，尽量弹出左侧元素。</p><p><a href="https://leetcode.cn/problems/spiral-matrix/"> 螺旋矩阵</a>，模拟，没有什么套路。直接用评论区大佬的题解，首先设定上下左右边界，其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界，判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案，若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理，不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">四数相加 II</a>，有四组数字，求每组取一个数字和为0的组合数量。A组和B组为一组，n方复杂度遍历和作为key，下标记录在map里。C组和D组为一组，求和，找map里是否有合适的记录。因为不需要去重，比<a href="https://leetcode.cn/problems/4sum/">四数之和</a>简单很多。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a>，这算法学一次忘一次。求文本串里第一个模板串的位置，首先要根据模板串求一个next数组，数组存的是下标之前的最长公共前后缀。得到next数组之后，遍历文本串当字符不匹配时，把指向模板串的下标调整到next数组指向位置。这样保证总共遍历一次文本串。时间复杂度变成了n + m，比n * m少得多。</p><p>求next数组也需要使用next数组的特性，和主函数一个套路，代码差不多可以背。</p><h2 id="双指针法-链表"><a href="#双指针法-链表" class="headerlink" title="双指针法 链表"></a>双指针法 链表</h2><p>双指针法，可以解决<a href="https://leetcode.cn/problems/remove-element/">移除元素</a>、<a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a>、<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a>（反转再反转），可以用java内置的方法来快速处理（正则匹配、链接、翻转）。</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a>，迭代法是初始化空结点，循环链表指向前一个元素。递归法不用记。</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a>，一次遍历找到结点和前置结点就可以了。</p><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a>常规方法是找到两个链表差值，从相同起点出发，比较是否相同。简单方法是，让两个指针同时出发，走完自己的路再走对方的，如果相等且不为空值就是交点。链表题目最好要画图理解清楚。</p><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a>让找到环的入口结点，首先要用快慢指针判断是否有环，如果有环，相遇结点和头节点同时出发，最终相遇的结点就是环的入口。</p><p>双指针经典题目当然不能缺少<a href="https://leetcode.cn/problems/3sum/"> 三数之和</a> <a href="https://leetcode.cn/problems/4sum/">四数之和</a>这种nSum题目了。套路都是一样的，先排序好数组，<strong>三数之和就是遍历一个数，另外两个用双指针，四数之和就是两层循环遍历两个数，另外两个用双指针</strong>。</p><p>遍历数字<strong>去重</strong>一般都是<code>if (i &gt; 0  &amp;&amp; nums[i] == nums[i - 1]) continue;</code>和回溯的题目一个道理。而<strong>双指针控制左右数字去重是在一组数据符合要求之后，去掉左右重复的数字</strong>，不能在其他情况下去重。</p><p><a href="https://leetcode.cn/problems/lru-cache/">LRU</a>，这个经典题目，要用双链表、哈希、头尾指针来解决。尤其是头尾指针，因为我们需要用尾指针保证O1复杂度删除结点。初始化需要注意，<code>head = new DLinkedNode();   tail = new DLinkedNode();   head.next = tail;   tail.next = head;</code>思路是使用的结点都放在头结点后。</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈和队列都能互相实现，两个栈可以实现一个队列，两个队列也可以实现一个栈（一个队列输出的时候把所有元素再输入到队尾也可以）。</p><p><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>和<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰式求值</a>，都可以用栈来实现。</p><p><a href="https://leetcode.cn/problems/min-stack/">最小栈</a>，这个题目有一个大坑，Integer对象的比较，不是简单的int值比较，所以要用equals才会比较正确。题目思路是，用两个栈，第一个栈正常操作，第二个栈维护最小值，当有更小值push，没有则不操作。</p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a>，这个题目使用了单调队列。单调队列不是优先队列，不是简单的把窗口里的元素单调排列。这一点和单调栈类似。我们需要一个双端队列来保证元素可以从队列两边弹出。1.加入元素时，队尾小于元素的全部从右边弹出。2.删除元素时，如果队头元素相等则从左边弹出。这样，我们才可以保证，队列头部的元素是滑动窗口最大值。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a>，这个题目使用了优先队列。优先队列定义的时候，要写清楚排序规则。并且使用了map的遍历操作，方法要记得。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的题目，首先要选择遍历方式，前中后序遍历和层序遍历。基本遍历代码这里就不放了，比较简单。我们要了解不同遍历方式的特点，灵活运用在解题上。</p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">求树最后一行最左边的值</a>，很明显要用层序遍历。但是我们可以从右往左的遍历，这样最后一个元素就是所求答案。</p><h3 id="前中后遍历"><a href="#前中后遍历" class="headerlink" title="前中后遍历"></a>前中后遍历</h3><p>二叉树的题目大多是选择一种合适递归遍历方式，<strong>核心是处理左右根三个结点</strong>。<strong>通常要处理四种情况：1. 根节点为null 2. 没有孩子 3. 只有一个孩子 4. 有左右孩子</strong>。简单情况下，后三种情况可以直接直接递归左右孩子，不做细分。</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>，用的后序遍历，四种情况可以简化为1和其他。也可以用<strong>前序遍历，和普通的回溯套路是一样的</strong>，用变量去记录深度，返回最大的深度。<a href="https://leetcode.cn/problems/path-sum/">路径总和</a>，也类似的思路，代码简单。其实不用去纠结前序还是后序遍历，理解成简单的递归就可以了，能解决问题就行。</p><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a>，要注意最小深度是最近叶子结点到根节点的距离。所以3情况不能返回1，而是返回孩子深度+1。</p><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a>，简单方法是左右孩子都调用<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>获取高度判断是否平衡，时间复杂度n方很高。另一种方法是把求最大深度的函数改（先获取左右孩子深度，然后再处理返回值判断是否平衡），因为底层二叉树不平衡的话，整个树就不平衡。</p><h3 id="特殊题型"><a href="#特殊题型" class="headerlink" title="特殊题型"></a>特殊题型</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>，判断一个二叉树是否是镜像对称的。这个题目比较特殊，不同于普通遍历就传一个参数，<strong>要传入两个结点进行比较</strong>。<code>return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left)</code></p><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a>，求节点个数当然可以n复杂度，但是<strong>完全二叉树有个规则，如果沿着左一直数和沿着右一直数相同的话，可以用公式直接求节点数量</strong>。如果不同，可以再去递归遍历左右孩子，个数相加。</p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序和后序遍历序列构造二叉树</a>，后序数组中找到最后一个值作为根，分割中序数组，根据结果分割后序数组，接着再从两个后序数组中找到最后一个元素作为左右孩子，递归进行。1.分割的时候，要统一规则，比如全按照左闭右开2. 分割后序数组要按照前序分完之后的数组大小3. 递归参数要写对</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a>，如果查到<strong>p</strong>或者<strong>q</strong>就返回结点，后序遍历，如果左右孩子都有返回值就说明找到了。</p><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a>，类似上面那个构造二叉树的方法，递归返回根节点，本题根节点需要返回中间位置的数组元素。</p><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a>，先序遍历，结点右孩子指向下一个遍历元素，但是会丢失原有右孩子。先序遍历的逆序，用右指针指向前一个结点即可。</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯套路很固定，我通常的做法就是用path来记录过程，res来记录结果。要考虑的问题是结束回溯的条件、选择路径、复原路径。有的题目还需要考虑一下剪枝的问题。简而言之，回溯可以看成树型结构，哪些结点是一层，哪些结点是一条路径，这些需要考虑清楚。</p><h3 id="组合-or-排列"><a href="#组合-or-排列" class="headerlink" title="组合 or 排列"></a>组合 or 排列</h3><p><a href="https://leetcode.cn/problems/combinations/">组合</a>问题，求从n个数中选择k个数的组合，代码结构很简单，要考虑剪枝（控制选择范围）。</p><p>组合跟排列的区别在于，<strong>组合需要排序并且控制选择的起始点。而排列每层都可以选全部选项，但要保证选项没有被选过。</strong></p><p>比如<a href="https://leetcode.cn/problems/combination-sum/">组合总和</a>这一题，如果误以为每层选择都可以选全部，那就犯错了。<a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a>这一题，相同元素只能选择一次，所以选择时要<strong>去重</strong>。去重，就是先把选项排列好，相同元素跳过。</p><p><a href="https://leetcode.cn/problems/permutations/">全排列</a>使用的是没有重复的数字，<a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a>使用的是可包含重复数字的序列。所以，后者也需要进行<strong>去重（排序+跳过）</strong>，同时因为是排列，也需要保证选项没被选过。</p><p><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a>和<a href="https://leetcode.cn/problems/permutations-ii/">全排列II</a>这两道题搞清楚，组合和排列是什么区别就比较明白了。</p><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>回溯题目，除了经典的组合排列问题，还有很多相似问题类型。比如<a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a>，<strong>aab截取a、ab、aab相当于[1, 2, 3]中选择1、2、3的组合问题</strong>，也能通过回溯的套路解决。判断回文串要用双指针方法。<a href="https://leetcode.cn/problems/restore-ip-addresses/">复原IP地址</a>也是类似问题。回溯函数里传的是起始点，选项是终止点。</p><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>子集问题其实就是组合问题，记录所有结点，而不是只记录叶子结点。<a href="https://leetcode.cn/problems/subsets/">子集</a>和<a href="https://leetcode.cn/problems/subsets-ii/">子集II</a>。<a href="https://leetcode.cn/problems/non-decreasing-subsequences/">递增子序列</a>这个题有些特殊，因为我们需要去重，但是不能把原有数组进行排序。所以我们<strong>选择set来去重</strong>，每一层都有一个set记录。</p><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p><a href="https://leetcode.cn/problems/n-queens/">N皇后</a>和<a href="https://leetcode.cn/problems/sudoku-solver/">解数独</a>，两个题目都是针对一个二维棋盘，遍历每一个位置，选择一个选项，然后继续回溯。<strong>别忘了，回溯之后把位置重置</strong>。其实，我认为难点在于判断棋盘是否可行。</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心没有固定套路，如果可以局部最优推出全局最优，举不出反例就可以用。所以还是要多看看贪心的题目，记住解题方法。</p><p><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a>，大饼干先要喂给胃口大的。</p><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a>，答案就是只记录摆动的数量。要记录当前差值和前一个差值，当前差值不是0但前一个差值是0（平坡），符合要求，当前差值为0肯定不符合要求，不符合要求的时候，就不用更新前一个差值，相当于没有摆动，不做记录。</p><p><a href="https://leetcode.cn/problems/gas-station/">加油站</a>，贪心思路是遍历每一天剩下的油，如果总和是负数则不能完成路线，遍历过程中负的最多的那一天的下一天就是起点。换一种思路，连续亏空最多的那一站，一定要最后走，等待前面所有正数填补</p><p><a href="https://leetcode.cn/problems/candy/">分发糖果</a>，这个问题不能一次遍历同时处理元素的左右糖果数量，会顾此失彼。先从前往后遍历，处理右边评分大于左边的情况，再从后往前遍历，处理左边评分大于右边的情况，并且第二次遍历的时候，要选择加一或者上次遍历结果的最大值（保证满足两次遍历关系）。</p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">根据身高重建队列</a>，题目明确一个元素要考虑两种维度的属性，常用解法就是先按照一种维度排序，再后续处理。按照身高降序排序，再按照另一个维度当作下标插入队列，就能解决。</p><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">单调递增的数字</a>，贪心：从后往前数，如果前一个数字大于当前数字，则当前数字变为<strong>9</strong>，前一个数字减少，保证数字最大。例如339-&gt; 329-&gt;299</p><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">监控二叉树</a>，这题是贪心和二叉树结合的难题。</p><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><p><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a>和<a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏II</a>都是考虑区间动态覆盖范围的题目，每次跳跃都要更新这个最大覆盖范围。前者只需要最新范围大于数组长度就能判断，后者每次超过跳跃范围再更新并且记录跳跃次数。</p><p>区间重叠问题，贪心也可以处理。<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a>意思是区间重叠的气球归为一组引爆。如何分组呢，我们首先把区间按照左边界排序，然后遍历左边界，左边界小于分组右边界的归为一组。缩小每个分组的右边界，<strong>重叠区间的右边界是不断在缩小的</strong>。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 区间的右边界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; right) &#123; <span class="hljs-comment">// 下一个分组</span><br>        res++;<br>        right = points[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 下一个重叠分组的右边界</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right = Math.min(points[i][<span class="hljs-number">1</span>], right); <span class="hljs-comment">// 不断缩小区间右边界</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a>也是类似解法，不断缩小重叠区间右边界，就可以保留最小区间。每个分组除了最小区间，其他的重叠区间都要移除。</p><p><a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a>和前面题目有点区别，因为合并的话要扩大区间右边界，而不是缩小了。<code>right = Math.max(right, intervals[i][1]);</code></p><p><a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a>这个题目如果用上述方法，复杂度至少也是nlogn，但是可以换一种方法，两次遍历得到结果。第一次遍历获取每个字母的最后位置，第二次遍历不断更新当前字符串的最后位置，遍历到相等位置就存。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划，跟“状态”这一词分不开，复杂一点的题目，有好几个状态转换，dp数组的递归方程也有好几个。当然，也有很多简单题目。只要推导出递归方程，考虑好dp数组初始化，就可以解答。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题，需要掌握01背包和完全背包，简单来说就是从固定的物品中选择一些装背包。01背包是同一物品只能选择一次，完全背包是可以选择多次。</p><p>背包问题，有二维dp数组和一维dp数组两种写法。二维的<code>dp[i][j]</code>表示0 - i下标物品中取，放在容量为j的背包里，价值总和最大多少。递归方程是<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>。用<strong>滚动数组转换为一维dp数组</strong>，代码就固定如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 求排列要外围遍历背包容量，求组合要外围遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 01背包遍历背包容量要倒序，保证物品不重复加入，完全背包要正序，可以重复加入同一物品</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>背包问题的代码套路很固定，要先把题目转换为背包问题，解决就简单一半了。举一些转换为背包问题的例子如下：</p><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a>，可以看作取集合元素装一半总和容量的背包，如果装满了就可以分割。所以说动态规划也不一定就是只作用于极值问题。</p><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头重量II</a>，题目让两个一组碎石头，也可以转换为装一半总和背包的问题，尽量装满就可以保证剩下的碎石最小，也算是一个极值问题。</p><p>背包问题，不是只有装满背包有多大价值一种类型，还可以求装满背包有多少中取法，<a href="https://leetcode.cn/problems/target-sum/">目标和</a>这个题目，先进行一些数学运算，然后转换为了求取法类型。要注意，dp[0]要初始化为1，递归方程改为<code>dp[j] += dp[j - nums[i]]</code>。</p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a>这个题，复杂度又有提升，需要同时满足两个维度的背包，所以dp数组上升为二维。</p><p>背包问题，还有一个考法需要考虑——求排列数量，而不是组合数量。简而言之，<strong>求排列要外围遍历背包容量，求组合要外围遍历物品</strong>。比如，1，5 和 5， 1是不同排列，外围遍历物品只会出现1，5的组合。<a href="https://leetcode.cn/problems/word-break/">单词拆分</a></p><p>完全背包的练习题有<a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和IV</a>，<a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a>，<a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>打家劫舍这类问题递归方程较简单，因为相邻屋子不能偷，那么状态就是偷或者不偷，从隔一个或者前一个状态得到最大值。</p><p><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍II</a>有要求首尾不能同时偷，所以要处理多种情况，归为两种偷法，考虑首不考虑尾 and 考虑尾不考虑首，两种情况都偷一遍，取最大值。</p><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍III</a>规定结构为二叉树，树型dp怎么办？其实，考虑每个结点也无非两种状态，偷 or 不偷。解决方案是，采用后序遍历求每个结点偷或者不偷的最大值，并且要返回上一层。题解采用大小为2的数组，res[0]保存不偷，res[1]保存偷的最大值。</p><h3 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h3><p>买卖股票问题，要获取最大利润。难度大的类型，要求我们明白动态规划的“状态”概念。</p><p>首先是买卖一次，<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">最佳时机I</a>，很简单，只需要记录前面天数的最低价格，获取最高差价就可以。</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖多次</a>，<strong>不对次数做出限制</strong>的话，也可以用贪心轻松解决。只要前后差价是正数就进行一次买卖。</p><p>如果对次数做出限制，就需要我们构造“状态”了。参考打家劫舍题目，每个屋子都有偷和不偷两个状态。比如，<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">最佳时机III</a>规定买卖2次，需要有5个状态。代码和解释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// dp[i][0]无操作</span><br>   <span class="hljs-comment">// dp[i][1]第一次已持有 的现金</span><br>   <span class="hljs-comment">// dp[i][2]第一次已卖出 的现金</span><br>   <span class="hljs-comment">// dp[i][3]第二次已持有 的现金</span><br>   <span class="hljs-comment">// dp[i][4]第二次已卖出 的现金</span><br>   <span class="hljs-comment">// 答案一定是第二次已卖出 的现金，已经包括了一次或者零次（最后一天多次买卖）</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prices.length;<br>       <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">5</span>];<br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>           <span class="hljs-comment">// 状态变换方程，要么继承前一天的状态，要么当天发生状态变化</span><br>           dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>           dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>           dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>           dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">最佳时机IV</a>，规定买卖k次，我们可以从上题总结出买卖k次的代码，有2 * k + 1个状态</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳时机含冷冻期</a>，规定每次卖完股票有一天冷冻期，之后才能购买股票。做这个题目，第一步还是划分好状态。持有股票，未持有股票（继承上次未持有 and 今天卖出股票，只有今天卖出股票会导致冷冻期出现），冷冻期状态。所以有四个状态。后续操作都一样。</p><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p>子序列的题目，重点在于构造二维dp数组，解决两个数组之间的问题。</p><p>求两个数组的<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a>这一题，<strong>首先<code>dp[i][j]</code>代表<code>nums1[:i-1]</code>和<code>nums2[:j-1]</code>的最大公共后缀长度</strong>，这样定义可以简化代码。其次，递归方程是<code> if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;</code>这是经典题目，要牢记。</p><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a>和上题对比一下，dp数组定义一样，状态转移不一样。当前元素不同的话， <code> dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</code> <a href="https://leetcode.cn/problems/uncrossed-lines/">不相交的线</a>这一题，看似没思路，但可以转换为这个题。</p><p><a href="https://leetcode.cn/problems/maximum-subarray/">最大子序和</a>这个题目，可以用贪心只算正和，也可以用dp来对比当前元素和前面元素的和，比较简单。</p><p><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a>是子序列的经典题目。我们先看有关的几个题目，<a href="https://leetcode.cn/problems/is-subsequence/">判断子序列</a>是要判断s是否为t的子序列，其实求出<a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a>为s的长度就可以判断了。通过这道题目可以看出，<strong>求最大公共子序列其实就是两个字符串都可以删除元素，判断子序列是t可以删除元素，s不可以</strong>。所以<code>dp[i][j] = dp[i][j - 1]</code>。</p><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a>，想求两个字符串相同的最小步数，要求只用删除操作。可以用两个字符串长度总和减去<a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a>长度。</p><p><a href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a>这一题是求s的子序列里有多少个t，比如rabbbit里有三个rabbit（删掉任一个b，都是不同的答案）。所以是s可以删掉，t不能删掉。<strong>匹配相同的时候，可以选择不匹配当前s[i - 1]。</strong>所以状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a>终于要解决了，要求两个字符串相同的最小步数，状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 删除相当于添加元素，修改元素在i-1 j-1基础上</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://leetcode.cn/problems/decode-ways/">解码方法</a>，每个数字要么单独一个数字，要么与前一个组成数字。</p><p><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a>，<code>dp[i][j]</code> 表示 s 的前 i 个字符是否能匹配 p 的前 j 个字符，一维是字符串，二维是表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (pChar == sChar || pChar == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 如果当前字符匹配，或者正则表达式中是 &#x27;.&#x27;，则可以选择匹配一个字符</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pChar == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 如果当前正则表达式字符是 &#x27;*&#x27;，则有两种选择：</span><br>                    <span class="hljs-comment">// 1. 匹配零次前面的字符，即跳过 &#x27;*&#x27;</span><br>                    <span class="hljs-comment">// 2. 匹配一次前面的字符，即使用 &#x27;*&#x27; 匹配一个字符，一定要把 &#x27;*&#x27; 留下</span><br>                    dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; (sChar == p.charAt(j - <span class="hljs-number">2</span>) || p.charAt(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>));<br>                &#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈，通常是题目要求在一维数组中，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。</p><p><a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>这道题目，记录数组元素右侧第一个大于自己的下标，维护一个递减的栈，当加入元素大于栈顶，就弹出所有不符合元素并且记录答案。</p><p><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素I</a>这道题目，两个数组之间有对应关系，这种情况可以用map来处理，这是一个技巧。下一个更大元素<a href="https://leetcode.cn/problems/next-greater-element-ii/">II</a>这题多了个循环数组的要求，可以通过下标取余遍历两次数组，长度是2 * len。</p><p><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a>，经典常考题目，当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度，简单解法是，用两个数组两次遍历，记录柱子左侧和右侧的最高高度，然后再遍历原数组求和。</p><p>这个方法还可以更简单，只用一次遍历就可以。用首尾指针去记录左右最大值，取较小的一个指针移动，同时就可以计算那个指针所在位置的雨水，很巧妙。</p><p>单调栈的方法写这个题目，比较麻烦，减少记忆负担算了。</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>对于图，简单来说就是两种遍历方式，一种是dfs，沿着一条路走到底，<strong>递归</strong>。另一种是bfs，一层一层搜索，<strong>队列</strong>。和树不同的点在于，图可能出现<strong>走回头路</strong>的情况，需要额外控制。</p><p>如果要求是遍历图的话，用dfs写代码更方便，如果是要求最短路径那就需要bfs。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>dfs的题目，和回溯法是一样的</strong>。代码上看，都要另外写一个回溯函数，需要考虑终止条件和返回值。函数里遍历所有选择，结构相当于树的同一层。递归返回后要撤销选择。</p><p><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">矩阵中的最长递增路径</a></p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>bfs的题目，必须要有队列来控制。目的就是求最短路径。<a href="https://leetcode.cn/problems/word-ladder/">单词接龙</a></p><h3 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h3><p>岛屿问题是图的经典问题，求数量的时候，可以dfs遍历的岛屿就下沉，这样也不会走回头路，算是一个技巧。求面积的时候，dfs就需要定义返回值为面积了。</p><p>有的题是从边界出发dfs，然后标记一些可以到边界的岛屿。有的题是通过高度差去标记可以流到边界的岛屿，思路都一样。</p><p><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">太平洋大西洋</a>，需要标记同时到两个边界的岛屿，建议用两次dfs，然后合并找出都标记的岛屿，代码好写很多。</p><p><a href="https://leetcode.cn/problems/making-a-large-island/">最大人工岛</a>，建议不要去遍历所有空格变成人工岛的情况，时间复杂度很高。而是去标记现有的成片岛屿获取面积，然后只需要把人工岛周围岛屿面积相加就可以了。</p><p><a href="https://leetcode.cn/problems/island-perimeter/">岛屿周长</a>，简单题，周长 &#x3D; 岛屿数量 * 4 - 2 * 接壤边数（统计右&#x2F;下或者左&#x2F;上）</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>太难，放弃</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.cn/problems/divide-two-integers/">两数相除</a>，不能用乘除取余运算，思路是用移位运算，把被除数一直移位，移到能被减掉的最大位置做减法，之后循环。异或判断符号很好用。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a>，<a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">和可被 K 整除的子数组</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>学习感悟</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>依赖和关联（简单理解）：当A使用B作为变量或者方法参数，叫依赖关系。当A使用B作为类属性，则叫关联关系，关联关系是一种强依赖关系。</li><li>多态的向上转型：父类类型 父类引用名 &#x3D; new 子类类型();<ul><li>编译阶段看左边的父类型，所以不能调用子类特有的成员，否则编译不通过</li><li>运行阶段看右边的子类型，调用方法从子类开始查找，一般调用子类重写的方法，属性无重写</li></ul></li></ul><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><ul><li><p>理解：单例模式确保某一个类只有一个实例，自行实例化，给系统提供全局访问方法</p></li><li><p>例子：任务管理器、身份证、打印池</p></li><li><p>优缺点</p><ul><li>缺点：违反“单一职责原则”</li></ul></li><li><p>类图：见书</p></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 静态私有成员变量</span><br>    <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">// 静态公有工厂方法，返回唯一实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jav">public class Singleton&#123;<br>public static void main(String a[])&#123;<br>        Singleton s1 = Singleton.getInstance();<br>        Singleton s2 = Singleton.getInstance();<br>        System.out.println(s1 == s2);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-迭代器模式"><a href="#2-迭代器模式" class="headerlink" title="2. 迭代器模式"></a>2. 迭代器模式</h2><ul><li>理解：<strong>聚合对象有两个功能：一是存储内部数据，二是遍历内部数据。把遍历行为提取成为迭代器。</strong></li><li>大概率只考察类图：抽象和具体迭代器 and 抽象和具体聚合类</li><li>例子：迭代器——电视遥控器    聚合类————电视机 </li><li>代码理解：<ul><li>抽象迭代器只有抽象迭代方法声明，抽象聚合类只有抽象创建迭代器方法声明 </li><li>具体聚合类：一是有数据，二是实现创建具体迭代器（返回一个具体迭代器对象），三是<strong>包含具体迭代器的类</strong>（即内部类的方式，也可以用另一种方式，单独写一个具体迭代器类，初始化需要具体聚合类参数）<img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240226235952395.png" alt="image-20240226235952395"></li></ul></li></ul><h2 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h2><ul><li><p>理解：将一系列算法封装起来，由环境类（使用算法的角色）选择使用哪种算法</p></li><li><p>例子：环境类（数组处理类）、抽象策略类、具体策略类（冒泡插入选择排序）</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000013615.png" alt="image-20240227000013615"></p></li><li><p>代码理解：</p><ul><li>环境类有set方法，用于设置具体策略类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>&#123; <span class="hljs-comment">// 环境类</span><br><span class="hljs-keyword">private</span> Strategy strategy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy strategy)</span>&#123;<br><span class="hljs-built_in">this</span>.strategy = strategy;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextAlgorithm</span><span class="hljs-params">(...)</span>&#123;<br>strategy.algorithm(...);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span>&#123; <span class="hljs-comment">// 抽象策略类 or 策略类接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algotithm</span><span class="hljs-params">(...)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123; <span class="hljs-comment">// 具体策略类A</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algotithm</span><span class="hljs-params">(...)</span>&#123;<br>        ...<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123; <span class="hljs-comment">// 具体策略类B</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algotithm</span><span class="hljs-params">(...)</span>&#123;<br>        ...<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>        <span class="hljs-type">StrategyA</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyA</span>();<br>        c.setStrategy(sa);<br>        c.contextAlgorithm(...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4. 工厂模式"></a>4. 工厂模式</h2><ul><li><p>三个模式之间的关系：</p><ul><li>当抽象工厂模式每一个具体工厂类只创造一个产品对象，抽象工厂退化为工厂方法模式</li><li>当工厂方法模式抽象工厂与具体工厂合并，只有一个统一的工厂来创建产品对象，工厂方法模式退化为简单工厂模式</li></ul></li><li><p>关于抽象工厂模式是否符合开闭原则</p><ul><li>如果增加产品族（由一个工厂生产的所有商品），只需要增加具体工厂，符合OCP</li><li>如果增加产品等级结构（同一种商品），要修改所有工厂类，不符合OCP</li></ul></li><li><p>关于工厂模式与策略模式的比较：工厂模式用于创建对象，策略模式用于选择各种方法</p></li><li><p>工厂方法UML图：</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000030157.png" alt="image-20240227000030157"></p></li></ul><h2 id="5-观察者模式"><a href="#5-观察者模式" class="headerlink" title="5. 观察者模式"></a>5. 观察者模式</h2><ul><li><p>很好理解</p></li><li><p>例子：主题类（猫），观察者（老鼠、狗）猫叫后老鼠和狗都有动作</p></li><li><p>类图：抽象主题（观察者数组、增加、删除观察者）、抽象观察者、具体主题（提醒观察者）、具体观察者</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000127357.png" alt="image-20240227000127357"></p></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySubject</span> &#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">observers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br><span class="hljs-comment">// 注册观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(MyObserver observer)</span> &#123;<br>observers.add(observer);<br>&#125;<br><br><span class="hljs-comment">// 删除观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(MyObserver observer)</span> &#123;<br>observers.remove(observer);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 抽象观察者（接口）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyObserver</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">response</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体主题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MySubject</span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;猫叫！！！&quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><br><span class="hljs-keyword">for</span>(Object obs:observers) &#123;<br>((MyObserver)obs).response();<br>&#125;<br><br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 具体观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyObserver</span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">response</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.print(<span class="hljs-string">&quot;狗也开始叫！！！&quot;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 具体观察者2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyObserver</span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">response</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.print(<span class="hljs-string">&quot;老鼠赶紧逃跑！&quot;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 客户端测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">MySubject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>MyObserver obs1, obs2, obs3;<br>obs1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouse</span>();<br>obs2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouse</span>();<br>obs3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>subject.attach(obs1);<br>subject.attach(obs2);<br>subject.attach(obs3);<br><br>subject.cry();<br><br>subject.detach(obs3);<br><br>subject.cry();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6. 建造者模式"></a>6. 建造者模式</h2><ul><li>和工厂模式很像，也是对象创建型模式，创建复杂的对象，关注各个配件的创建，有一个指挥者</li></ul><h2 id="7-原型模式"><a href="#7-原型模式" class="headerlink" title="7. 原型模式"></a>7. 原型模式</h2><ul><li>通过复制(clone)原型来创建对象</li></ul><h2 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8. 适配器模式"></a>8. 适配器模式</h2><ul><li><p>让目标类可以做适配类的行为，类适配要用接口，对象适配只用继承</p></li><li><p>分为类适配器和对象适配器</p><ul><li>类适配器实现目标类，继承适配类的接口（比如让robot可以学dog叫，因为狗叫是dog已实现的方法，所以继承dog，实现robot）（抽象和实现的区别：抽象可以选择父类方法调用，实现必须实现接口所有方法）</li><li>对象适配器继承目标类，关联适配类（把适配类当作变量）</li></ul></li><li><p>使用时候，用目标类作为父类创建适配器</p></li><li><p>类图：</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000141080.png" alt="image-20240227000141080"></p></li></ul><h2 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9. 桥接模式"></a>9. 桥接模式</h2><ul><li><p>一个类有两个独立变化的维度，把两个维度分离开，独立扩展</p></li><li><p>抽象化：把类的共同性质抽取出来形成抽象类，比如不同颜色的毛笔都是毛笔</p></li><li><p>实现类：另一个维度的实现部分，比如毛笔的颜色</p></li><li><p>抽象类与实现类有聚合关系（桥）</p></li><li><p>例子：不同操作系统上播放多种格式的视频文件、描述不同制造商以及制造的电器种类</p></li><li><p>类图</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000150502.png" alt="image-20240227000150502"></p></li></ul><h2 id="10-组合模式"><a href="#10-组合模式" class="headerlink" title="10. 组合模式"></a>10. 组合模式</h2><ul><li><p>想到组合模式就应该想到树形结构图，对叶子和容器的使用要有一致性</p></li><li><p>用抽象构件作为叶子和容器的抽象，容器和构件建立组合关系，容器有构件的数据可以遍历</p></li><li><p>例子：水果盘里有水果和水果盘；文件夹浏览和文件浏览方式；</p></li><li><p>类图</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000200509.png" alt="image-20240227000200509"></p></li></ul><h2 id="11-装饰模式"><a href="#11-装饰模式" class="headerlink" title="11. 装饰模式"></a>11. 装饰模式</h2><ul><li><p>对原有对象的功能进行扩展</p></li><li><p>对类功能进行复用时应该多用关联关系，少用继承关系</p></li><li><p>UML图和组合模式很像，但原理不同</p></li><li><p>抽象构件有一个默认具体构件类，比如煎饼果子默认加蛋</p></li><li><p>理解：咖啡加很多调料，如果用继承关系，把各种调料方式的咖啡都建立一个子类，会有类爆炸。所以使用装饰模式，建立各种调料的类，用调料调用咖啡进行装饰。</p></li><li><p>例子：变形金刚；</p></li><li><p>类图（抽象装饰类和具体装饰类的初始化有说法）</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000208991.png" alt="image-20240227000208991"></p></li></ul><h2 id="12-外观模式"><a href="#12-外观模式" class="headerlink" title="12.  外观模式"></a>12.  外观模式</h2><ul><li><p>对外提供一个统一的接口用来访问子系统</p></li><li><p>对客户屏蔽子系统组件，降低客户类与子系统类的耦合度</p></li><li><p>eg：网站首页有各个子栏目；电源总开关控制很多子开关</p></li><li><p>UML图很简单，外观类关联很多子系统类</p></li><li><p>违反OCP，增加子系统会修改外观类代码，抽象外观模式符合OCP</p></li><li><p>体现单一职责，体现迪米特</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000217504.png" alt="image-20240227000217504"></p></li></ul><h2 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13. 代理模式"></a>13. 代理模式</h2><ul><li><p>代理对象控制对对象的访问</p></li><li><p>很简单：代理对象有对象的变量，自己有控制等级变量，根据控制等级，调用对象的方法。因为要满足OCP所以继承一个抽象对象</p></li><li><p>客户端调用代理对象，完成对对象的代理访问</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000224921.png" alt="image-20240227000224921"></p></li></ul><h2 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14. 命令模式"></a>14. 命令模式</h2><ul><li><p>将一个请求封装成一个对象，发送请求的对象只需要知道如何发送请求，不必知道如何完成请求</p></li><li><p>分为请求发送控制者和请求接收者，抽象请求和具体请求。发送者有很多请求对象，请求对象有发送接收者成员变量。发送者调用请求，请求调用接收者的方法</p></li><li><p>客户端建立请求控制对象，建立请求，初始化请求控制对象</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000331277.png" alt="image-20240227000331277"></p></li></ul><h2 id="15-中介者模式"><a href="#15-中介者模式" class="headerlink" title="15. 中介者模式"></a>15. 中介者模式</h2><ul><li><p>中介者模式可以使对象之间的关系数量急剧减少，变成以中介者为中心的星状结构（私聊变群聊）</p></li><li><p>分为抽象中介和具体中介、抽象同事和具体同事，具体中介有同事数组作为成员变量，抽象同事有抽象中介作为成员变量，用来调用中介的方法进行通信</p></li><li><p>考代码的话稍微有点复杂，画类图很简单</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000339228.png" alt="image-20240227000339228"></p></li></ul><h2 id="16-备忘录模式"><a href="#16-备忘录模式" class="headerlink" title="16. 备忘录模式"></a>16. 备忘录模式</h2><h2 id="17-状态模式"><a href="#17-状态模式" class="headerlink" title="17. 状态模式"></a>17. 状态模式</h2><ul><li><p>对象在不同状态下的行为不同，且可以自动转换状态</p></li><li><p>例子：论坛用户等级、银行账户状态、两个开关同时开关</p></li><li><p>优缺点</p><ul><li>缺点：对开闭原则支持不太好，可以切换状态的状态模式，增加状态需要修改负责状态转换的代码</li></ul></li><li><p>类图包括环境类（拥有状态的对象）、抽象状态类（封装与状态相关的行为）、具体状态类</p><p><img src="https://cky1122-blog.oss-cn-shanghai.aliyuncs.com/blog/image-20240227000347541.png" alt="image-20240227000347541"></p></li></ul><h2 id="18-职责链模式"><a href="#18-职责链模式" class="headerlink" title="18. 职责链模式"></a>18. 职责链模式</h2><h2 id="19-享元模式"><a href="#19-享元模式" class="headerlink" title="19. 享元模式"></a>19. 享元模式</h2><h2 id="20-解释器模式"><a href="#20-解释器模式" class="headerlink" title="20. 解释器模式"></a>20. 解释器模式</h2><h2 id="21-模板方法模式"><a href="#21-模板方法模式" class="headerlink" title="21. 模板方法模式"></a>21. 模板方法模式</h2><h2 id="22-访问者模式"><a href="#22-访问者模式" class="headerlink" title="22. 访问者模式"></a>22. 访问者模式</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法糖</title>
    <link href="/2023/09/22/Java%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/09/22/Java%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><p>为什么专门要有一篇针对Java语法的文章呢，其实不是为了去梳理所有语法知识，而是针对算法题目这一块，有需要专门掌握的内容。比如常用的各种集合方法，注意事项。这些都是我在刷算法题目中积累的内容。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="字符串转其他"><a href="#字符串转其他" class="headerlink" title="字符串转其他"></a>字符串转其他</h3><p><strong>1. 字符串与数组之间的转换：</strong></p><ul><li><p>字符串转换为字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span>[] charArray = str.toCharArray(); <span class="hljs-comment">// 返回字符数组 [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>字符数组转换为字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] charArray = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray); <span class="hljs-comment">// 返回字符串 &quot;Hello&quot;</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(charArray); <span class="hljs-comment">// 返回字符串 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>2. 字符串与列表之间的转换：</strong></p><ul><li><p>字符串转换为列表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,World&quot;</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">asList</span><span class="hljs-punctuation">(</span><span class="hljs-variable">str</span><span class="hljs-operator">.</span><span class="hljs-variable">split</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> 返回列表 <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;World&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure></li><li><p>列表转换为字符串：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">asList</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;World&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">join</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-operator">,</span> <span class="hljs-variable">list</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> 返回字符串 <span class="hljs-string">&quot;Hello,World&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>3. 字符串与集合之间的转换：</strong></p><ul><li><p>字符串转换为集合：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,World&quot;</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">asList</span><span class="hljs-punctuation">(</span><span class="hljs-variable">str</span><span class="hljs-operator">.</span><span class="hljs-variable">split</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> 返回列表 <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;World&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-built_in">Set</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-variable">HashSet</span><span class="hljs-operator">&lt;&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-variable">list</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> 返回集合 <span class="hljs-punctuation">&#123;</span><span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;World&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>集合转换为字符串：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">set</span> = <span class="hljs-literal">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-built_in">String</span> str = <span class="hljs-built_in">String</span>.<span class="hljs-keyword">join</span>(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-built_in">set</span>); <span class="hljs-comment">// 返回字符串 &quot;Hello,World&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>4. 字符串与基本类型之间的转换：</strong></p><ul><li>字符串转其他：<code>Integer.parseInt() Double.parseDouble() Boolean.parseBoolean()</code></li><li>其他转字符串：<code>String.valueOf() Integer.toString() Double.toString() Boolean.toString()</code></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Java语言中的<code>Arrays</code>类是一个工具类，位于<code>java.util</code>包下。这个类包含用来操作数组（例如排序和搜索）的各种静态方法。</p><p>下面是<code>Arrays</code>类的一些重要方法：</p><ul><li>**sort()**：对数组进行排序。</li><li>**binarySearch()**：使用二分查找算法查找数组中的元素。</li><li>**equals()**：比较两个数组是否相等。</li><li>**fill()**：使用指定的值填充数组。</li><li>**asList()**：将数组转化为<code>List</code>。</li></ul><p>关于<code>Arrays</code>类和<code>Collection</code>、<code>List</code>的关系：</p><ul><li><code>Arrays</code>类专门用来操作数组，而<code>Collection</code>和<code>List</code>是Java集合框架中的接口，主要用来操作集合。</li><li><code>Arrays.asList()</code>方法可以将一个数组转化为<code>List</code>，但需要注意的是，这个方法返回的<code>List</code>大小是固定的，不能增加或删除元素，因为它实际上只是对原数组的一种视图。</li><li>另外，<code>List</code>、<code>Set</code>、<code>Queue</code>都是继承或实现了<code>Collection</code>接口，因此有一些通用的操作，比如add、remove等，可以通过<code>Collections</code>类（请注意和<code>Collection</code>接口区分）提供的一些静态方法来操作。比如<code>Collections.sort()</code>可以对<code>List</code>进行排序。</li></ul><h2 id="集合方法合集"><a href="#集合方法合集" class="headerlink" title="集合方法合集"></a>集合方法合集</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><code>add(E element)</code>: 将指定的元素添加到列表的末尾。</li><li><code>get(int index)</code>: 返回列表中指定索引位置的元素。</li><li><code>set(int index, E element)</code>: 替换列表中指定索引位置的元素。</li><li><code>remove(int index)</code>: 删除列表中指定索引位置的元素。</li><li><code>size()</code>: 返回列表中的元素数量。</li><li><code>isEmpty()</code>: 判断列表是否为空。</li><li><code>contains(Object obj)</code>: 判断列表是否包含指定的元素。</li><li><code>indexOf(Object obj)</code>: 返回指定元素在列表中首次出现的索引。</li><li><code>subList(int fromIndex, int toIndex)</code>: 返回列表中指定范围的子列表。</li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>ArrayList独特方法：</strong></p><ul><li><code>trimToSize()</code>: 将ArrayList的容量调整为当前元素的数量，以减少内存占用。</li><li><code>ensureCapacity(int minCapacity)</code>: 增加ArrayList的容量，以确保其至少能容纳指定的最小元素数量。</li><li><code>toArray()</code>: 返回包含ArrayList中所有元素的数组。</li><li><code>toArray(T[] array)</code>: 将ArrayList中的元素复制到指定的数组中，并返回该数组。</li><li><code>removeRange(int fromIndex, int toIndex)</code>: 移除列表中指定范围的元素。</li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList独特方法：</strong></p><ul><li><code>addFirst(E element)</code>: 在列表的开头插入指定的元素。</li><li><code>addLast(E element)</code>: 在列表的末尾插入指定的元素。</li><li><code>getFirst()</code>: 返回列表的第一个元素，但不移除它。</li><li><code>getLast()</code>: 返回列表的最后一个元素，但不移除它。</li><li><code>removeFirst()</code>: 移除并返回列表的第一个元素。</li><li><code>removeLast()</code>: 移除并返回列表的最后一个元素。</li><li><code>offer(E element)</code>: 在列表的末尾插入指定的元素。</li><li><code>offerFirst(E element)</code>: 在列表的开头插入指定的元素。</li><li><code>offerLast(E element)</code>: 在列表的末尾插入指定的元素。</li><li><code>poll()</code>: 移除并返回列表的第一个元素。</li><li><code>pollFirst()</code>: 移除并返回列表的第一个元素。</li><li><code>pollLast()</code>: 移除并返回列表的最后一个元素。</li><li><code>peek()</code>: 返回列表的第一个元素，但不移除它。</li><li><code>peekFirst()</code>: 返回列表的第一个元素，但不移除它。</li><li><code>peekLast()</code>: 返回列表的最后一个元素，但不移除它。</li></ul><p>除了实现Deque接口外，LinkedList还实现了List接口和Queue接口，因此您可以将LinkedList用作列表或队列的实例。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><code>add(E element)</code>: 将指定的元素添加到集合中。</li><li><code>remove(Object obj)</code>: 从集合中删除指定的元素。</li><li><code>contains(Object obj)</code>: 判断集合是否包含指定的元素。</li><li><code>size()</code>: 返回集合中的元素数量。</li><li><code>isEmpty()</code>: 判断集合是否为空。</li><li><code>clear()</code>: 清空集合中的所有元素。</li><li><code>iterator()</code>: 返回一个迭代器，用于遍历集合中的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;T&gt; iterator = set.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-comment">// 对元素进行操作</span><br>&#125;<br><span class="hljs-comment">// 第二种</span><br><span class="hljs-keyword">for</span> (T element : set) &#123;<br>    <span class="hljs-comment">// 对元素进行操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><code>put(K key, V value)</code>: 将指定的键值对添加到映射中。</li><li><code>get(Object key)</code>: 返回与指定键关联的值。</li><li><code>remove(Object key)</code>: 从映射中删除指定键及其对应的值。</li><li><code>containsKey(Object key)</code>: 判断映射是否包含指定的键。</li><li><code>containsValue(Object value)</code>: 判断映射是否包含指定的值。</li><li><code>size()</code>: 返回映射中键值对的数量。</li><li><code>isEmpty()</code>: 判断映射是否为空。</li><li><code>keySet()</code>: 返回映射中所有键的集合。</li><li><code>values()</code>: 返回映射中所有值的集合。</li><li><code>entrySet()</code>: 返回映射中所有键值对的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;K, V&gt; map = ...; <span class="hljs-comment">// 假设这里是你的Map对象</span><br><br><span class="hljs-keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;<br>    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>    <span class="hljs-comment">// 对键值对进行操作</span><br>&#125;<br><span class="hljs-comment">// 迭代器遍历</span><br></code></pre></td></tr></table></figure><h3 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h3><p>Java提供了<code>Queue</code>接口来定义队列的行为，但它并没有提供具体的实现类。<code>Queue</code>接口继承自<code>Collection</code>接口，因此可以使用任何<code>Collection</code>的实现类来实现队列的功能，包括<code>List</code>。</p><p>栈不是直接使用<code>List</code>、<code>Map</code>或<code>Set</code>这三种集合类型来实现的。尽管这些集合类型可以用于存储数据，但它们并没有提供专门用于栈操作的接口或方法。在 Java 中，<code>java.util.Stack</code> 类提供了栈的基本实现。下面是 <code>Stack</code> 类的常用方法列表：</p><ol><li><code>void push(E item)</code>: 将元素压入栈顶。</li><li><code>E pop()</code>: 弹出并返回栈顶元素。</li><li><code>E peek()</code>: 返回栈顶元素，但不移除它。</li><li><code>boolean empty()</code>: 判断栈是否为空。（<strong>注意，不是isEmpty</strong>）</li><li><code>int search(Object o)</code>: 查找指定元素在栈中的位置，如果存在则返回相对于栈顶的位置（栈顶为 1），否则返回 -1。</li></ol><p>在 Java 中，栈通常是通过数组或链表来实现的。Java 标准库中提供了两种主要的栈实现：</p><ol><li><p><strong>基于数组的实现：</strong> <code>java.util.Stack</code> 类是一个基于动态数组的栈实现。它是 <code>Vector</code> 类的一个子类，因此支持所有 <code>Vector</code> 的操作，但通常推荐使用 <code>ArrayDeque</code> 代替，因为 <code>ArrayDeque</code> 是 <code>Deque</code> 接口的实现，性能更好。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.push(<span class="hljs-number">3</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">poppedElement</span> <span class="hljs-operator">=</span> stack.pop();<br></code></pre></td></tr></table></figure></li><li><p><strong>基于链表的实现：</strong> <code>java.util.LinkedList</code> 类是一个双向链表实现的 <code>List</code> 接口，也可以被用作栈。在栈的操作中，<code>LinkedList</code> 提供了 <code>push</code>（在链表头添加元素）和 <code>pop</code>（从链表头移除元素）等方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.push(<span class="hljs-number">3</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">poppedElement</span> <span class="hljs-operator">=</span> stack.pop();<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong></p><ul><li>在实际使用中，更常见的是使用 <code>Deque</code> 接口来实现栈。<code>Deque</code> 是一个双端队列（Double-Ended Queue）接口，可以在两端进行插入和删除操作，因此也适用于栈的实现。<code>ArrayDeque</code> 类是一个 <code>Deque</code> 接口的实现，具有良好的性能，通常用于代替 <code>Stack</code> 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.push(<span class="hljs-number">3</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">poppedElement</span> <span class="hljs-operator">=</span> stack.pop();<br></code></pre></td></tr></table></figure><p>无论选择基于数组还是链表的实现，实际的选择通常取决于使用场景和性能需求。如果需要高效的栈操作，可能会选择 <code>ArrayDeque</code>，但如果在操作中需要频繁地插入和删除元素，可能会选择 <code>LinkedList</code>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><code>length()</code>：返回字符串的长度。</li><li><code>charAt(int index)</code>：返回指定位置的字符。</li><li><code>isEmpty()</code>：检查字符串是否为空。</li><li><code>toUpperCase()</code>：将字符串转换为大写形式。</li><li><code>toLowerCase()</code>：将字符串转换为小写形式。</li><li><code>equals(Object obj)</code>：比较两个字符串是否相等。</li><li><code>equalsIgnoreCase(String anotherString)</code>：忽略大小写比较两个字符串是否相等。</li><li><code>concat(String str)</code>：将指定字符串连接到原字符串的末尾。</li><li><code>substring(int beginIndex)</code>：返回从指定位置开始到字符串末尾的子串。</li><li><code>substring(int beginIndex, int endIndex不包含)</code>：返回指定范围内的子串，。</li><li><code>split(String regex)</code>：根据给定的正则表达式将字符串拆分成字符串数组。</li><li><code>trim()</code>：去除字符串开头和结尾的空白字符。</li><li><code>replace(char oldChar, char newChar)</code>：用新字符替换字符串中的旧字符。</li><li><code>replaceAll(String regex, String replacement)</code>：使用新字符串替换满足正则表达式的部分字符串。</li><li><code>contains(CharSequence sequence)</code>：检查字符串是否包含指定的子串。</li><li><code>startsWith(String prefix)</code>：检查字符串是否以指定的前缀开头。</li><li><code>endsWith(String suffix)</code>：检查字符串是否以指定的后缀结尾。</li><li><code>indexOf(String str)</code>：返回指定子串在字符串中第一次出现的位置。</li><li><code>lastIndexOf(String str)</code>：返回指定子串在字符串中最后一次出现的位置。</li><li><code>String.format(format, args)</code>: <code>String.format(&quot;Name: %s, Age: %d, Height: %.2f meters&quot;, name, age, height);</code><ul><li><code>%s</code>: 字符串</li><li><code>%d</code>: 十进制整数</li><li><code>%f</code>: 浮点数</li><li><code>%b</code>: 布尔值</li><li><code>%c</code>: 字符</li><li><code>%x</code>: 十六进制整数</li><li><code>%n</code>: 换行符</li></ul></li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ul><li><strong><code>int length()</code></strong><ul><li>返回当前字符串的长度。</li></ul></li><li><strong><code>int capacity()</code></strong><ul><li>返回<code>StringBuilder</code>的当前容量。</li></ul></li><li><strong><code>StringBuilder append(String str)</code></strong><ul><li>将指定的字符串追加到此字符序列。</li></ul></li><li><strong><code>deleteCharAt(int index)</code></strong><ul><li>删除给定索引位置的字符。</li></ul></li><li><strong><code>StringBuilder delete(int start, int end)</code></strong><ul><li>删除从<code>start</code>到<code>end-1</code>索引位置的字符。</li></ul></li><li><strong><code>String substring(int start)</code></strong><ul><li>返回一个新的<code>String</code>，它包含此序列当前长度的子字符串。</li></ul></li><li><strong><code>String substring(int start, int end)</code></strong><ul><li>返回一个新的<code>String</code>，它包含此序列从<code>start</code>到<code>end-1</code>索引位置的子字符串。</li></ul></li></ul><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream流分为1.创建Stream；2.中间操作；3.终端操作三部分。</p><h3 id="1-创建Stream"><a href="#1-创建Stream" class="headerlink" title="1. 创建Stream"></a>1. 创建Stream</h3><p>有多种方式可以创建Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br>Stream&lt;String&gt; streamFromList = list.stream(); <span class="hljs-comment">// 从集合创建</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">codeString[] array = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;;<br>Stream&lt;String&gt; streamFromArray = Arrays.stream(array); <span class="hljs-comment">// 从数组创建</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; streamOfValues = Stream.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>); <span class="hljs-comment">// stream.of创建</span><br></code></pre></td></tr></table></figure><h3 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2. 中间操作"></a>2. 中间操作</h3><p>中间操作是对数据进行一系列处理的过程，返回的仍然是一个Stream。常见的中间操作有：</p><p><code>filter(Predicate&lt;T&gt; predicate)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stream.filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>)); <span class="hljs-comment">// 过滤掉不符合条件的元素。</span><br></code></pre></td></tr></table></figure><p><code>map(Function&lt;T, R&gt; mapper)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stream.map(String::toUpperCase); <span class="hljs-comment">// 对每个元素应用函数。</span><br></code></pre></td></tr></table></figure><p><code>distinct()</code>：去重，去掉重复的元素。</p><p><code>sorted()</code>：排序元素。</p><h3 id="3-终端操作"><a href="#3-终端操作" class="headerlink" title="3. 终端操作"></a>3. 终端操作</h3><p>终端操作是对Stream进行最终操作，得到最终的结果。一旦终端操作执行，Stream就被消费，不能再被使用。常见的终端操作有：</p><p><code>forEach(Consumer&lt;T&gt; action)</code>：对每个元素执行指定操作。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">stream.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br></code></pre></td></tr></table></figure><p><code>collect(Collectors.toList())</code>：将Stream元素收集到一个List中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;String&gt; collectedList = stream.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure><p><code>count()</code>：返回Stream中元素的个数。</p><p><code>anyMatch(Predicate&lt;T&gt; predicate)</code>：判断是否至少匹配一个元素。</p><p><code>allMatch(Predicate&lt;T&gt; predicate)</code>：判断是否全部匹配。</p><p><code>noneMatch(Predicate&lt;T&gt; predicate)</code>：判断是否没有一个元素匹配。</p><p><code>findFirst()</code>和<code>findAny()</code>：返回第一个元素或任意一个元素。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式可以看作是匿名函数的一种形式，它提供了一种简洁的方式来传递行为（方法）给方法。</p><p>Lambda表达式的基本语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(parameters) -&gt; &#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>参数列表：参数可以为空或非空，如果有多个参数，用逗号分隔。</li><li>箭头符号 <code>-&gt;</code>：箭头符号将参数列表和Lambda体分隔开。</li><li>Lambda体：可以是表达式或语句块。如果是表达式，结果将自动返回；如果是语句块，需要使用 <code>&#123;&#125;</code> 包裹，并且需要手动指定 <code>return</code> 语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以Runnable接口为例</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello, Lambda!&quot;</span>);<br><br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br><br><span class="hljs-comment">// 使用Lambda表达式遍历集合</span><br>names.forEach(name -&gt; System.out.println(name));<br><br><span class="hljs-comment">// 使用Lambda表达式进行条件过滤</span><br>names.removeIf(name -&gt; name.length() &gt; <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// Comparator作为函数式接口使用Lambda表达式</span><br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>);<br>names.sort((s1, s2) -&gt; s1.compareTo(s2));<br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（Regular Expression，简称 regex 或 regexp）是一种用于匹配字符串的模式描述工具。它是由字符和特殊字符组成的字符串，用于定义搜索模式。正则表达式在文本处理、字符串匹配和替换等方面非常强大，几乎所有主流编程语言都支持正则表达式操作。</p><p>以下是一些正则表达式的基本概念和常见用法：</p><ol><li><strong>普通字符：</strong> 大多数字符在正则表达式中都是普通字符，它们匹配它们自身。例如，正则表达式 <code>abc</code> 匹配字符串中的 “abc”。</li><li><strong>元字符：</strong> 正则表达式中有一些特殊字符称为元字符，它们具有特殊的含义。例如：<ul><li><code>.</code>：匹配任意一个字符（除了换行符）。</li><li><code>^</code>：匹配字符串的开始。</li><li><code>$</code>：匹配字符串的结束。</li><li><code>*</code>：匹配前一个字符的零次或多次。</li><li><code>+</code>：匹配前一个字符的一次或多次。</li><li><code>?</code>：匹配前一个字符的零次或一次。</li><li><code>[]</code>：字符类，匹配方括号中的任意一个字符。</li><li><code>|</code>：或操作，匹配两边任意一边的内容。</li></ul></li><li><strong>字符类：</strong> 使用方括号 <code>[]</code> 来定义一个字符类，表示匹配其中的任何一个字符。例如，<code>[aeiou]</code> 可以匹配任何一个元音字母。</li><li><strong>反义字符类：</strong> 使用 <code>^</code> 在字符类的开头表示反义，即匹配不在字符类中的任何字符。例如，<code>[^0-9]</code> 表示匹配非数字字符。</li><li><strong>预定义字符类：</strong> 有一些常用的字符类有特殊的缩写，如：<ul><li><code>\d</code>：匹配任意数字（相当于 <code>[0-9]</code>）。</li><li><code>\w</code>：匹配任意字母数字字符（相当于 <code>[a-zA-Z0-9]</code>）。</li><li><code>\s</code>：匹配任意空白字符（空格、制表符等）。</li></ul></li><li><strong>量词：</strong> 用来指定一个模式的匹配次数。<ul><li><code>&#123;n&#125;</code>：匹配前一个字符恰好 n 次。</li><li><code>&#123;n,&#125;</code>：匹配前一个字符至少 n 次。</li><li><code>&#123;n,m&#125;</code>：匹配前一个字符至少 n 次，但不超过 m 次。</li></ul></li><li><strong>分组：</strong> 使用圆括号 <code>()</code> 可以将一系列字符作为一个整体进行处理。例如，<code>(ab)+</code> 可以匹配 “ab”、”abab”、”ababab” 等。</li><li><strong>转义字符：</strong> 使用反斜杠 <code>\</code> 来转义元字符，使其失去特殊含义，变成普通字符。例如，<code>\.</code> 匹配实际的点而不是任意字符。</li><li><strong>匹配模式：</strong> 有时需要指定匹配模式，如大小写不敏感匹配。在一些正则表达式引擎中，可以使用 <code>i</code> 表示不区分大小写，<code>m</code> 表示多行模式等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>知识分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>842真题笔记</title>
    <link href="/2022/10/24/842%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/24/842%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="842真题笔记"><a href="#842真题笔记" class="headerlink" title="842真题笔记"></a>842真题笔记</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>快速排序选取最终位置中间的元素最快、有序时做<strong>最多</strong>的比较次数</li><li>直接选择和二分插入比较次数与初始排列无关</li><li>两个降幂排列的一元多项式相加，总比较次数是O(M+N)</li><li>一颗有n个关键字的m阶b树中查找，最多读盘</li><li>1+1+2+1+2+3……&#x3D;&#x3D;n(n+1)(n+2)&#x2F;6</li><li>选择最坏情况下排序最快，且最节约内存的算法——堆排序</li><li>递归汉诺塔2^n-1</li></ul><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul><li>确认测试属于需求验证环节</li><li>程序编码属于软件构造过程</li><li>视图4+1模型</li><li>Editor适合作为XmlEditor的父类</li><li>项目启动不属于软件项目管理活动</li><li>敏捷过程以人为核心驱动、瀑布模型是文档驱动</li><li>需求是否正确：操作员应该在2个小时完成车辆加油（错，软件不能对人作出限制）</li><li>用例图是软件详细设计文档中不需要描述的</li><li>LSP要求继承关系必须实现多态</li><li>软件程序设计时，最为重要的代码质量是易读性</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>设备驱动程序负责把用户提交的逻辑I&#x2F;O请求转化为物理I&#x2F;O操作的启动和执行</li><li>Unix系统中，文件的索引结构存放在inode节点中</li><li>OPT以后最久未使用、LRU最近最久未使用</li><li>银行家算法破坏循环等待</li><li>Linux系统中的stab分配器，采用伙伴系统内存管理方式</li><li>操作系统教科书中，解决进程互斥和同步问题的基本机制：信号量、临界区、消息传递</li><li>实时系统进程调度采用抢占式高优先级</li><li>solaris的多线程实现方式是混合式</li><li>虚拟技术包括<ul><li>多道程序设计技术，虚拟CPU，提高CPU资源利用率</li><li>交换技术，虚拟内存，中级调度，平衡负载调度</li><li>SPOOLING技术，虚拟设备，提高设备利用率</li></ul></li><li>死锁的原因：系统资源不足和进程推进顺序不当</li><li>文件系统和文件目录的主要作用都是实现对文件的按名存取</li><li>从逻辑结构来划分，文件可以分为两种形式：有结构的记录式文件、无结构的流式文件</li><li>死锁定理是用来检测死锁</li><li>磁盘的读写单位是扇区</li><li>操作系统的抽象：方便管理和调度<ul><li>进程是对CPU的抽象</li><li>虚存是对内存的抽象</li><li>文件是对设备的抽象</li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>二层交换机的工作机制</li><li>NAT的作用和工作原理</li><li>网状拓扑结构的可靠性高、总线建网容易、星型集中控制</li><li>ACL：访问控制列表</li><li>N个节点的星型拓扑结构中，有N-1条物理链路</li><li>IOS镜像不能从NVRAM下载</li><li>被选为某个网段转发流量的交换机端口称为指定端口</li><li>STP端口状态：阻塞、监听、学习、转发、禁止，没有传输</li><li>哪条语句禁止对10.10.1.0&#x2F;24的访问</li><li>最低逻辑接口地址不能作为路由器ID号</li><li>LCP：PPP上传输的链路层协议；NCP：PPP上传输的网络层协议</li><li>STP（生成树协议）用来解决广播风暴问题</li><li>无线局域网标准IEEE802.11g规定最大速率54Mbps</li><li>STP中，根交换机是根据最小的交换机ID来选择的</li><li>CSMA&#x2F;CD协议是非确定性协议</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>842数据结构</title>
    <link href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><ul><li>斐波那契数列时间复杂度<ul><li>递归方法用差分方程求，时间复杂度n方</li><li>非递归时间复杂度n</li></ul></li></ul><h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h2><ul><li><p>随机存取：已知首元素地址和位序，O(1)时间内直接得到目标地址（顺序表）</p></li><li><p>顺序表可以顺序存取和随机存取，链表只能从表头顺序存取元素</p></li><li><p>头指针和头结点的区分：不管带不带头结点，头指针都始终指向链表第一个结点，而头结点是带头结点链表的第一个结点</p></li><li><p>链表的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    LNode *next;<br>&#125;LNode, *LinkList;<br><br><span class="hljs-comment">// 树的链表定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;<br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3. 栈和队列"></a>3. 栈和队列</h2><ul><li><p>都属于线性表</p></li><li><p>栈和队列的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> data[MaxSize];<br>    <span class="hljs-type">int</span> top;<br>&#125; SqStack;<br><br><span class="hljs-comment">// 队列顺序存储</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> data[MaxSize];<br>    <span class="hljs-type">int</span> front, rear;<br>&#125; SqQueue;<br><br><span class="hljs-comment">// 队列链式存储</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span> *next;<br>&#125; LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    LinkNode *front, *rear;<br>&#125; LinkQueue;<br><br><br></code></pre></td></tr></table></figure></li><li><p>栈的top初始值-1，队列的front指向头元素，rear指向队尾元素下一位置(循环队列一般空一个位置，用来区分队列空和队列满的判别条件)</p></li><li><p>应用题 </p><ul><li>栈：括号匹配 表达式求值</li></ul></li><li><p>特殊矩阵压缩</p><ul><li>上三角 or 下三角 除了存三角区域的元素，还要存另外半三角的常量一次</li><li>三对角矩阵：非零元素都在三角区域内，第一行和最后一行只有两个非零数，其余行是三个</li></ul></li><li><p>稀疏矩阵 </p><ul><li>三元组（行、列、值）</li><li>十字链表</li></ul></li></ul><h2 id="4-树"><a href="#4-树" class="headerlink" title="4. 树"></a>4. 树</h2><ul><li><p>树的度数（边数）等于节点数减一</p></li><li><p>二叉树：叶子结点个数等于度为2的结点数加一           N0 &#x3D; N2 + 1</p></li><li><p>含有N个结点的二叉链表中含有N+1空链域（线索二叉树）</p></li><li><p>先后序不能确定唯一二叉树</p></li><li><p>线索二叉树，有两个标志位，ltag &#x3D; 1 表示 lchild 是结点左前驱</p></li><li><p>顺序存储法要存所有结点</p></li><li><p>王道：先序序列abcd的不同二叉树个数相当于以abcd入栈的出栈序列：用亚特兰数 1&#x2F;(n+1)Cn 2n</p></li><li><p>先序中序后序递归遍历中，栈的作用</p><ul><li>递归算法的话，只是visit的位置不同</li><li>先序和中序用栈非递归，都是先遍历左子树入栈，后出栈一个遍历右子树，先序是先访问再入栈，中序是先入栈，弹出再访问</li></ul></li><li><p>树的存储结构</p><ul><li>双亲表示法（顺序存储结构，除了数据还有双亲下标）</li><li>孩子表示法（类似邻接表，结点有孩子链）</li><li>孩子兄弟表示法（又叫二叉树表示法）</li></ul></li><li><p>树和森林的遍历</p><ul><li>树的遍历（因为不是二叉树，不分为左右子树，只分根和子树）<ul><li><strong>先根遍历</strong>：与对应二叉树的<strong>先序序列</strong>相同</li><li><strong>后根遍历</strong>：与对应二叉树的<strong>中序序列</strong>相同</li><li>层次遍历：和二叉树层次遍历思想相同</li></ul></li><li>森林的遍历<ul><li>先序遍历：访问第一颗树的根 先序遍历第一棵树的子树森林 先序遍历剩余</li><li>中序遍历：中序遍历第一颗树 访问根结点 中序遍历剩余</li></ul></li><li>记忆方式：不用二叉树的后序遍历</li></ul></li><li><p>并查集：一种集合，用树的形式</p></li><li><p>二叉搜索树要满足中序遍历是有序的，不是简单的左结点小右结点大</p></li><li><p>王道：三叉树计算带权路径：用0构造完全三叉树</p></li></ul><h2 id="5-图"><a href="#5-图" class="headerlink" title="5. 图"></a>5. 图</h2><ul><li>概念<ul><li>简单图：不存在重复边，不存在顶点到自身的边。</li><li>完全图（简单完全图）：任意两个顶点之间都存在边</li><li>子图：顶点是子集，边集也是子集</li><li>连通图：任意两个顶点都是连通的</li><li>连通分量：无向图的极大连通子图是连通分量</li><li>强连通：对应有向图的连通</li><li>生成树：包含全部顶点的极小连通子图</li><li>简单路径：顶点不重复出现的路径</li></ul></li><li>邻接矩阵：一维数组存顶点，二维数组存边</li><li>邻接表：两种结点（顶点表结点、边表结点）<ul><li>顶点表结点（一个数组）：值和边表指针</li><li>边表结点：值和下一个边的指针</li></ul></li><li>十字链表和邻接多重表</li><li>BFS <ul><li>空间复杂度：顶点队列o(v)</li><li>时间复杂度：每个顶点访问一次，访问相邻点时有区别，邻接表访问次数等于e，邻接矩阵每个点都要访问v次。邻接表<strong>o(v+e)<strong>，邻接矩阵</strong>o(v^2)</strong></li></ul></li><li>DFS<ul><li>空间复杂度：栈高度为顶点数，o(v)</li><li>时间复杂度：与BFS分析一致，都是需要查边</li></ul></li><li>最小生成树<ul><li>prim：（p点）选距离最近的点加入集合，适用于边多 <strong>o(v^2)</strong></li><li>kruskal：选最小边，适用于点多</li></ul></li><li>最短路径<ul><li>单源最短Dijkstra算法：dist数组、path数组、集合S（初始为v0）<strong>o(v^2)</strong></li><li>每对顶点最短路径Floyd算法 <strong>o(v^3)</strong></li></ul></li><li>DAG：有向无环图<ul><li>AOV用点表示活动： 拓扑排序：每次选择没有前驱的点输出，删边</li><li>AOE用边表示活动： 关键路径：最长路径<ul><li>ve事件最早开始：（从前往后算，最大值）</li><li>vl事件最晚开始：（从后往前算，最小值）</li><li>e活动最早开始：起点最早开始时间            ve</li><li>l活动最晚开始：终点最晚时间减去活动时间      vl-t</li></ul></li></ul></li></ul><h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6.查找"></a>6.查找</h2><ul><li><p>动态查找表：需要动态插入删除的查找表</p></li><li><p>顺序查找</p><ul><li>一般：成功<strong>（n+1）&#x2F;2</strong>，失败<strong>n+1</strong></li><li>有序：（画图，判定树）成功不变，失败**(1+2+..+n+n)&#x2F;n+1**</li></ul></li><li><p>折半查找（有序）</p><ul><li>代码（low&lt;&#x3D;high，low向下取整，high&#x3D;mid-1，low&#x3D;mid+1）</li><li>所以最后一次查找是low与high相等</li><li>判定树找ASL 时间复杂度<strong>o（logn）</strong></li></ul></li><li><p>分块查找（索引顺序查找）</p><ul><li>块内无序，索引结点（最大值）有序</li><li>顺序或折半查找索引，顺序查找块内          ASL &#x3D; L1 + L2</li></ul></li><li><p>二叉排序树</p><ul><li>平衡二叉树<strong>o（logn）</strong>，单支树<strong>o（n）</strong></li><li>删除：用后继或前驱代替 </li><li>平衡二叉树：找最近不平衡结点作为a<ul><li>LL：右转 RR：左转</li><li>LR：左右（先代替左再代替右） RL：右左</li></ul></li><li>平衡二叉树的题目：所有非叶节点平衡因子为1，Cn &#x3D; Cn-1 + Cn-2 + 1</li></ul></li><li><p>B树</p><ul><li>m叉树：结点至少Ceil(m&#x2F;2)-1个数，至多m-1</li><li>所有叶结点出现在同一层次</li><li>插入时分裂：中间位置m&#x2F;2（上取整）插入父结点</li><li>删除：用后继或前继；兄弟够，父亲代替自己，兄弟上去；兄弟不够，父亲下来，和兄弟合并。</li><li>m叉B树的结点数量</li><li>与B+树的不同：B+树可以顺序查找</li></ul></li><li><p>散列表</p><ul><li>散列函数：线性直接不会冲突；除留余数（取不大于表长的质数）；平方中间几位；</li><li>处理冲突：线性探测（顺序下一个）；平方探测0，1，-1，4，-4；拉链法（同义词存链表）</li><li>ASL 比较次数（不冲突是1）</li></ul></li><li><p>散列查找</p><ul><li>散列表装填因子增大，更容易发生冲突</li></ul></li></ul><h2 id="7-排序"><a href="#7-排序" class="headerlink" title="7.排序"></a>7.排序</h2><ul><li>上图记忆方法<ul><li>堆排序、归并排序时间复杂度固定nlogn；直接选择都是n^2</li><li>选择排序、希尔排序、快排不稳定</li><li>快速排序平均最好都是nlogn，冒泡和直插最好n，平均n^2</li><li>快排辅存要nlogn</li></ul></li><li>插入排序：将待排序记录插入，前面排好序的子序列<ul><li>可以折半查找插入位置，再移动之后的元素</li><li>希尔排序：取不同步长的数，分组排序</li></ul></li><li>交换排序：每次将元素的最终位置找到<ul><li>快排（内部最快排序算法）：如果区域个数不对称，时间复杂度n^2，递归栈深度n</li></ul></li><li>选择排序：每一趟选取最小的元素，作为有序队列的元素。<ul><li>简单选择：每一趟选最小的，与相应位置交换。移动很少，<strong>比较次数固定</strong></li><li>堆排序（不断输出堆顶元素）<ul><li>建立堆：初始顺序放置，之后不断调整非叶子结点</li><li>输出元素：堆顶与堆尾元素交换，调整。</li><li>插入：放在末端，调整。</li></ul></li></ul></li><li>归并排序和基数排序<ul><li>归并排序：把单个元素作为子表，n路排序后归并。 eg：对10TB的数据文件进行排序，使用外部排序</li><li>基数归并：选10作为基数，个十百千位分别接龙。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>考研</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>842计网</title>
    <link href="/2022/10/22/%E8%AE%A1%E7%BD%91/"/>
    <url>/2022/10/22/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul><li><p>默认网关是离当前主机最近的路由器的端口地址，子网掩码和默认网关子网掩码相同</p></li><li><p>数据链路层、网络层、传输层都有流量控制的功能，数据链路层是相邻节点之间的、网络层是整个网络、传输层是端到端的流量控制</p></li><li><p>片偏移是8B的整数倍（一总8片首4）</p></li><li><p>不需要为虚电路预分配带宽，虚电路建立的时候需要进行路由选择</p></li><li><p>TCP规定当发送方收到同一报文的3个重复确认时，认为丢失，执行快速重传</p></li><li><p>UDP实现分用，即传输层把数据交付到目的进程，所以要用目的端口号</p></li><li><p>CSMA&#x2F;CA进行信道预约的时候，用请求发送帧RTS和允许发送帧CTS</p></li><li><p>路由表下一跳是下一个路由的地址</p></li><li><p>IP路由器不能确保传输的IP分组不丢失，会进行差错检验，丢弃出错的报文</p></li><li><p>不同网段的主机需要通过路由器才能通信</p></li><li><p>DNS查询最少次数0，最多次数&#x3D;4（根+com+xyz+abc）eg: <a href="http://www.abc.xyz.com/">www.abc.xyz.com</a></p></li><li><p>后退N帧算法，接收到0，2，3确认，则会重传3之后的帧，因为1其实已经接受</p></li><li><p>FTP是基于TCP的控制连接</p></li><li><p>DNS的查询域名的流程</p><ul><li>递归，用户查本地服务器，本地服务器开始递归查，只发送一条</li><li>递归和迭代，用户查本服务器，本地服务器迭代查询，发送多条</li></ul></li><li><p>集线器的特点</p></li><li><p>FCS：帧检验序列，存储循环冗余校验的冗余码</p></li><li><p>交换机的原理</p></li><li><p>NAT的缺点：通信必须由专用网内的主机发起，专用网内的主机不能充当服务器</p></li><li><p>NAPT：网络地址和端口号转换，对于专用网的应答，NAPT根据不同目的端口号，从转换表中找到正确目的主机</p></li><li><p>MPLS：多协议标记交换，给每一个IP数据包一个固定长度的“标记”，然后用硬件标记它们，使得IP数据包转发过程加快，用于解决网络中负载均衡和拥塞问题。</p></li><li><p>OSI参考模型再网络层提供无连接和面向连接服务，在传输层提供面向连接服务</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>842软件工程</title>
    <link href="/2022/10/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2022/10/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><ul><li>技术评审是以提高软件质量为目的的技术活动</li><li>面向数据流软件设计方法一般是把数据流图中的数据流化分为交换流和事务流两种流，再将数据流图映射为软件结构</li><li>概要设计的结果是提供一份模块说明书</li><li>可行性研究要进行一次简化的需求分析，一般归于计划时期</li><li>便于软件维护不是软件需求规格的目标</li><li>结构设计和数据流图有关</li><li>测试依据是需求规格说明的是确认测试</li><li>黑盒测试属于动态测试</li><li>软件测试最基础的是单元测试</li><li>程序三种基本控制结构是回溯、递归和迭代</li><li>软件周期中花费最多的阶段是软件维护</li><li>结构化方法重要指导思想是自顶向下，逐步分解</li><li>面向对象观点建立的三种模型，对象模型是最重要的</li><li>数据流图，用圆或者椭圆来表示加工</li><li>与设计测试数据无关的文档是项目开发设计</li><li>系统开发需求分析阶段重要工作之一是数据定义</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>考研</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>842操作系统</title>
    <link href="/2022/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-os概述"><a href="#1-os概述" class="headerlink" title="1. os概述"></a>1. os概述</h2><ul><li><p>中断</p><ul><li>外中断，也称中断，即从CPU外部发出的中断，包括可屏蔽INTR和不可屏蔽NMI，不可屏蔽中断在关中断状态不受中断标志位的影响，即使关中断也会响应。</li><li>内中断，也称异常，从CPU内部发出的中断，都是不可屏蔽的中断，包括<ul><li>故障：缺页、除数为0、运算溢出</li><li>自陷：系统调用</li><li>终止：硬件故障如控制器出错、存储器校验错。和外部中断合称硬件中断。</li></ul></li></ul></li><li><p>处理器运行模式</p><ul><li>用户态（目态）——非特权指令</li><li>核心态（管态、内核态）——特权指令——管理资源、原语、时钟、中断（硬件完成从用户态到核心态的转换，自动保存断点。os执行中断服务程序、保存PSW、保存中断屏蔽字、通用寄存器的值）</li></ul></li><li><p>系统调用过程</p><ul><li>首先要传递系统调用参数，因为之后会进入内核态，用户不能传参。再执行trap指令</li></ul></li><li><p>用户态到核心态由硬件中断完成，核心态到用户态由os程序执行后完成</p></li><li><p>子程序调用与中断处理</p><ul><li>子程序调用只需要保存程序断点，即下一条指令的地址</li><li>中断处理不仅要保存断点，还要保存PSW内容</li></ul></li><li><p>CPU检测到中断信号后，由硬件自动保存断点（PC）和PSW，之后硬件找到中断信号对应的中断向量，中断向量指明中断服务程序的入口地址序，保存中断屏蔽字、保存各通用寄存器值，提供中断服务。其中，中断向量表由os开机初始化。</p></li><li><p>系统调用和中断处理是两个过程，都有图</p></li><li><p>外设和主机之间数据传送通过软件完成（中断服务程序）</p></li><li><p>外设准备数据时间不能小于中断处理时间（写入速度不能比读出速度更快）</p></li><li><p>操作系统初始化时，要创建中断向量表，用于实现中断处理</p></li><li><p>中断请求的产生与当前指令无关，因为中断请求来自CPU外部</p></li><li><p>保护中断现场的时候关中断，执行中断处理程序时开中断</p></li><li><p>I&#x2F;O指令实现的数据传送发生在通用寄存器和I&#x2F;O端口（暂存信息的寄存器）之间</p></li></ul><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h2><ul><li><p>进程是除了CPU以外的系统资源的分配单元，线程是处理机的分配单元</p></li><li><p>创建进程就是申请一个空白PCB，并且初始化一些信息</p></li><li><p>线程的实现方式（os只为内核级线程建立TCB）</p><ul><li>用户级线程：线程切换不需要转换到内核空间，进程管理由应用程序完成，每次只有一个线程执行</li><li>内核级线程：线程切换需要到核心态执行，内核同时调度同一进程的多个线程</li></ul></li><li><p>处理器的三级调度模型</p></li><li><p>进程在临界区时候可以进行处理机调度（王道原题），在内核临界区时不可以</p></li><li><p>带权周转时间是作业周转时间与作业实际运行时间的比值</p></li><li><p>先有资源调度（在队列里给进程排位置），后有进程切换，广义的进程调度包括选择进程和切换进程。</p></li><li><p>上下文切换与模式切换</p><ul><li>上下文切换只能发生在内核态（进程切换）</li><li>模式切换：用户态和内核态之间的切换。进程运行在用户态，因中断或异常进入内核态，执行后返回原进程。</li></ul></li><li><p>处理机调度算法中</p><ul><li>时间片和多级队列肯定是抢占式</li><li>短作业优先会饥饿</li><li>响应比：（等待时间+要求服务时间）&#x2F;（要求服务时间）</li></ul></li><li><p>让权等待：进程不能进入临界区时，应立即释放处理器。硬件方法和皮特森方法都不能实现，记录型信号量引入了阻塞，可以实现让权等待。</p></li><li><p>临界区互斥需要满足“忙则等待”、“空闲让进”、“有限等待”，不一定要实现“让权等待”，如皮特森。</p></li><li><p>软件实现互斥方法理解</p><ul><li>单标志法：turn&#x3D;0意为P0可以进入，之后修改为1。如果P0不进入，则P1也不能进。违背“<strong>空闲让进</strong>”。</li><li>双标志法（flag数组2）先检查：定义flag数组，flag[i]为false则Pi未进入。先检查对方未进入，再进入并设置标志。如果同时检查都通过，会同时进入，违背“<strong>忙则等待</strong>”。</li><li>双标志法后检查：先设置标志为true，再检测。如果都设置为true，都进不去。出现“<strong>饥饿</strong>”现象。</li><li>皮特森算法：算法一和三的结合。每个进程设置flag后再设置turn标志，同时检测对方的flag和turn。</li></ul></li><li><p>硬件方法有TestAndSet和Swap</p></li><li><p>整型信号量wait里面是循环，会阻塞。记录型信号量，wait会把进程加到等待队列中，使用block原语阻塞单个进程。signal会唤醒。</p></li><li><p>关中断时，进程不会被中断</p></li><li><p><strong>PV问题解题思路</strong></p><ul><li><p>生产者消费者问题</p><ul><li>把进程分类，一种进程对应一个函数，函数内中文描述动作</li><li>考虑每个动作前P什么，如果P，找出V。缓冲区必须互斥访问。</li><li>所有PV写完之后定义信号量</li><li>检查多个P连续的时候，是否可能死锁，调整多个P的顺序。</li></ul></li><li><p>读者写者问题（同类不互斥，异类互斥）</p><ul><li>用count计数，同类进程第一个上锁，最后一个解锁</li><li>读写公平：读和写再各加一个PV操作，这样写进程就不会一直不被访问，而是按顺序访问。</li></ul></li><li><p>哲学家问题（只有一类进程）</p><ul><li>只有能拿两双筷子才能就餐</li></ul></li><li><p>理发师问题</p><ul><li>当前等待服务顾客数量num，用Lock互斥访问</li><li>客户和理发师都有一个信号量</li></ul></li></ul></li><li><p>死锁与循环等待：死锁的进程互相占有对方需要的资源，循环等待中的进程可以从别的地方获取资源从而打破等待的循环链。</p></li><li><p>死锁预防：破坏死锁的四个条件 死锁避免：银行家算法 死锁检测与解除（分配资源的时候不会做任何事）</p><ul><li>破坏互斥：资源共享</li><li>破坏不剥夺：得不到满足的话释放所有资源</li><li>破坏请求并保持（占有且等待）：预先静态分配法，运行前一次性申请完所有资源</li><li>破坏循环等待：顺序资源分配法，进程只能按照编号递增申请资源，不存在申请对方的资源。</li></ul></li><li><p>管程：同一时刻只能由一个进程在执行，进程使用wait阻塞后，管程使用权释放，可以有另一个进程进入管程</p></li><li><p>银行家算法：当系统处于安全状态时，系统中一定没有死锁进程</p></li><li><p>死锁定理：从资源出去的边意思是已经分配的资源</p></li><li><p>PCB不包含进程地址空间大小</p></li></ul><h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h2><ul><li>链接的时候，把相对地址构成逻辑地址</li><li>装入的时候，把逻辑地址改为物理地址（地址重定位）</li><li>高级语言源程序转换为可执行目标文件过程：预处理☞编译☞汇编☞链接</li><li>进程的内存映像：当程序调入内存运行，就形成了进程的内存映像。包括代码段（只读，多个进程可共享）、数据段、PCB、堆栈</li><li>进程映像：程序、数据、栈和属性的集合</li><li>内存保护中，cpu先把逻辑地址和界地址寄存器（逻辑地址最大值）比，再加上基地址寄存器（重定位寄存器物理地址值）的值</li><li>分段为什么方便进程的只读内存区域共享：若共享40页的代码区，每个进程都要建立40个页表项，而分段的话，每个进程只需要一个段表项（始址+段长）</li><li>覆盖用于同一个程序或进程，交换用于不同作业进程之间。</li><li>紧凑技术：内存时不时对进程进行移动和整理，用于克服外部碎片。</li><li>首次适应算法性能最好，最佳适应算法最容易产生内存碎片</li><li>连续分配管理和非连续例子：1GB的作业，需要连续的1GB空间，非连续的话，可以分散。</li><li>分页不会有外部碎片，有很少的内部碎片，分段有外部碎片</li><li>进程未执行的时候，页表始址和页表长度存放在进程PCB中，进程调度执行时，放入页表寄存器中。</li><li>地址变换过程由硬件自动完成</li><li>分级页表：例如1024个页表，每次查页表都需要调入这么多页面，如果分级，只需要调入一级页表，然后调入一个二级页表，总共两个页表，不用浪费空间存储无关页表。</li><li>段的保护</li><li>请求分页的地址变换机构图</li><li>请求分页置换算法<ul><li>OPT：以后最长不被使用</li><li>LRU：最近最久未使用</li><li>改进时钟clock：替换指针：访问位，修改位     0,0  0,1  1,0  1,1</li><li>FIFO：先进先出</li><li>第二次机会算法：FIFO和普通CLOCK算法结合</li></ul></li><li>不同进程共享一个段，各自的逻辑段号可能不同</li><li>计算地址的时候，要注意高位补零</li></ul><h2 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h2><ul><li>文件的逻辑结构（理解）<ul><li>顺序结构：记录定长，读写大批记录时效率高</li><li>索引文件：可以根据位序计算地址，有定长和变长（需要索引表）</li><li>索引顺序文件：索引+顺序，索引间有序，索引内顺序查找，类似分块排序。eg：字典</li><li>直接文件或散列文件：就是通过哈希算物理地址</li></ul></li><li>文件分配方式☞非空闲块；文件存储空间管理☞空闲块管理</li><li>文件物理结构<ul><li>分配方式<ul><li>连续分配（数组）</li><li>链接分配（链表）：隐式链接（链表，顺序查找）；显式链接（FAT表就是静态链表数组，也显示空闲块）</li><li>索引分配：每个文件有个索引块，包括所有盘号。</li><li>UNIX混合索引分配（重点计算题！）：10个直接地址，一级间址，二级间址，三级间址。</li></ul></li><li>空闲管理<ul><li>空闲表法（内存动态分配）空闲链表法</li><li>位示图</li><li>成组链接法UNIX：空闲表+空闲链表法：顺序n个空闲盘块号存在第一个成组链块中，成组链块的最后一个空闲盘块号指的那个块，作为成组链块，保存第二组空闲盘块。</li></ul></li></ul></li><li>目录：FCB的有限集合，一个FCB就是一个文件目录项</li><li>Linux操作系统中，”&#x2F;dev&#x2F;hda”就是绝对路径，”.&#x2F;ls”是相对路径，”.”表示当前工作目录</li><li>建立硬链接（索引结点）和软链接（符号链）的流程图<ul><li>建立符号链接，引用计数值直接复制，删除操作对符号链接不可见</li><li>建立硬链接，引用计数值加1，删除文件在引用计数值减1，值不为0则不能删除文件</li></ul></li><li>os维护一个包含所有打开文件信息的表（打开文件表）。每个进程的打开文件表存储对文件的使用信息，系统表包含文件相关信息如位置，进程调用open时，在进程打开表中增加条目指向系统表。系统表对每个文件有一个计数器，计数为0，可以删去。</li><li>文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区有一个独立的文件系统。MBR主引导记录负责引导计算机，确定活动分区，读入引导块。引导块程序负责启动分区中的操作系统。</li><li>Linux系统的FCB 中的文件名和其他管理信息分开，其他信息单独组成一个数据结构，称为索引节点inode，此索引节点在磁盘上的位置由 inode 号标识</li><li>磁盘格式化<ul><li>物理格式化：把空白版分成扇区，包括确定扇区校验码。</li><li>把操作系统记录在磁盘上，第一步磁盘分成多个柱面，即磁盘分区。</li><li>第二步是逻辑格式化（创建文件系统），将文件系统数据结构存储到磁盘上，包括目录、空闲或已分配的</li></ul></li><li>可以提高文件访问速度<ul><li>延迟写：先将数据存入缓冲区，以备不久后访问，减少了访问磁盘次数</li><li>提前读、分配连续簇、磁盘高速缓存</li></ul></li><li>计算数据所在磁盘的柱面号、磁头号、扇区号的程序是设备驱动程序，因为该功能和设备类型有关，设备驱动程序由厂家提供</li><li>树形目录解决了多用户之间文件命名问题，不同目录下可以由相同文件名</li><li>open将文件属性从外存复制到内存打开文件表的一个表目中，将表目索引返回给用户</li></ul><h2 id="5-I-O管理"><a href="#5-I-O管理" class="headerlink" title="5. I&#x2F;O管理"></a>5. I&#x2F;O管理</h2><ul><li>I&#x2F;O设备：磁盘、打印机、鼠标、键盘、光盘等</li><li>I&#x2F;O接口（设备控制器）：位于CPU与设备之间，与CPU和设备通信。结构图！</li><li>I&#x2F;O端口：设备控制器中可以被CPU直接访问的寄存器（数据、状态、控制寄存器）</li><li>I&#x2F;O控制方式（理解）<ul><li>直接控制（轮询）和中断驱动方式都是一次一个字，且都经过CPU存入主存。前者CPU发出读命令之后要等待I&#x2F;O设备准备好，后者发命令之后不需要等待，只需要在指令周期末尾检查中断，若I&#x2F;O设备发出中断，则接受一个字。</li><li>DMA在设备和内存间开辟一条数据通路，传输的是数据块，只需要在开始和结束传输前请求CPU。</li><li>通道是一个处理机，与DMA区别：DMA需要CPU来控制数据块大小和内存位置，通道方式由通道控制；DMA对应一台设备和内存，通道可以控制多台设备与内存。</li><li>通道与一般处理机区别：通道指令类型单一，没有自己的内存，与CPU共享内存。</li></ul></li><li>DMA传送前由设备驱动程序设置传送参数</li><li>I&#x2F;O软件的层次记忆（软件☞软件☞程序☞程序）<ul><li>用户层I&#x2F;O软件（使用read命令）</li><li>设备独立性软件（设备无关性：逻辑设备和物理设备，每个设备都能执行的共有操作）</li><li>设备驱动程序（I&#x2F;O进程与设备控制器之间的通信程序，每个设备接受命令之后行为不同，解析read指令）</li><li>中断处理程序（中断当前进程，执行命令）</li></ul></li><li>硬盘格式化时，要对硬盘进行分区，创建硬盘分区表。分区完成后，每个分区初始化文件系统，创建文件系统根目录，如果使用UNIX文件系统，还要创建索引结点表。</li><li>磁盘高速缓存不同于介于CPU与内存之间的小容量存储器，而是指利用内存中的存储空间暂存磁盘中读的信息。</li><li>高速缓存与缓冲区的区别：（都是内存空间一部分）<ul><li>高速缓存有的，低速设备必有。缓冲区存放的是低速设备给高速设备的数据，不一定有备份。</li><li>如果高速缓存没有，会访问低速设备。但有缓冲区的话，不会直接访问低速设备。</li></ul></li><li>缓冲区处理数据时间（处理机C，输出到处理机M，输入到缓冲区T）<ul><li>单缓冲max(c, t) + m</li><li>双缓冲max(c, m) + t</li></ul></li><li>SPOOLING假脱机技术（理解）<ul><li>输入输出井（磁盘）、输入输出缓冲区（内存）、输入输出进程</li><li>因为向磁盘输出数据速度快于向打印机输出数据，所以当有用户进程请求打印输出，SPOOLING系统同意打印，但不会给进程分配打印机。由假脱机管理进程把打印数据送给缓冲区暂存，送入输出井。对用户进程而言，打印已经完成。</li><li>要打印的作业在输出井排队，等到设备空闲，按顺序打印。（SPOOLING就是多了输入井和输出井这两个排队环节）</li><li>图（预输入程序、井管理程序、缓输出程序）</li></ul></li><li>设备分配方式<ul><li>静态分配：一次性分配所有设备，不会出现死锁</li><li>动态分配</li></ul></li><li>磁盘驱动调度算法<ul><li>扫描算法scan：最后一道；循环扫描：最后一道然后从头开始</li><li>电梯算法：最后一个请求</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识分享</tag>
      
      <tag>考研</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
